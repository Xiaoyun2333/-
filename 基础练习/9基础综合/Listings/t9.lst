C51 COMPILER V9.60.0.0   T9                                                                01/09/2023 19:43:07 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE T9
OBJECT MODULE PLACED IN .\Objects\t9.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE t9.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\t9.lst
                    -) TABS(2) OBJECT(.\Objects\t9.obj)

line level    source

   1          #include<stc15.h>
   2          #include<intrins.h>
   3          //================================================
   4          sbit s5 = P3^2;
   5          sbit s4 = P3^3;
   6          //================================================
   7          code unsigned char tab[] = {0xc0,0xf9,0xa4,0xb0,
   8                                      0x99,0x92,0x82,0xf8,
   9                                      0x80,0x90,0x88,0x83,
  10                                      0xc6,0xa1,0x86,0x8e};//数码管0~F，"-"为0xbf
  11          unsigned char dspbuf[] = {255,255,255,255,255,255,255,255};//数码管显示缓冲
  12          
  13          unsigned char hour = 0;
  14          unsigned char min = 0;
  15          unsigned char sec = 0;
  16          unsigned char count = 0;
  17          unsigned char led = 0xff;
  18          unsigned char r_sbuf;
  19          //================================================
  20          void init_ls138(unsigned char value);//选择P0通道
  21          void cls();//关闭led和蜂鸣器
  22          void led_check();//LED开机自检
  23          void smg_check();//数码管开机自检
  24          void Timer0Init();//50毫秒@11.0592MHz
  25          void service_t0();//t0中断服务函数
  26          void smg_show();//数码管显示
  27          void key_alone();//按键控制
  28          void UartInit();//9600bps@11.0592MHz
  29          void service_uart();//串口中断服务
  30          void sendchar(unsigned char Char);//发送字节
  31          void command();//执行上位机命令
  32          //================================================
  33          void Delay100ms();//自检函数延时
  34          void Delay1ms();//数码管动态扫描延时
  35          //================================================
  36          void main()
  37          {
  38   1        cls();
  39   1        led_check();
  40   1        smg_check();
  41   1        Timer0Init();
  42   1        UartInit();
  43   1        EA = 1;
  44   1        while(1)
  45   1        {
  46   2          command();
  47   2          smg_show();
  48   2          key_alone();
  49   2        }
  50   1      }
  51          //================================================
  52          void init_ls138(unsigned char value)
  53          {
  54   1        switch(value)
C51 COMPILER V9.60.0.0   T9                                                                01/09/2023 19:43:07 PAGE 2   

  55   1        {
  56   2          case 4:
  57   2            P2 = P2 & 0x1f | 0x80;
  58   2          break;
  59   2          case 5:
  60   2            P2 = P2 & 0x1f | 0xa0;
  61   2          break;
  62   2          case 6:
  63   2            P2 = P2 & 0x1f | 0xc0;
  64   2          break;
  65   2          case 7:
  66   2            P2 = P2 & 0x1f | 0xe0;
  67   2          break;
  68   2          default:
  69   2            P2 = P2 & 0x1f;
  70   2          break;
  71   2        }
  72   1      }
  73          void cls()
  74          {
  75   1        init_ls138(5);
  76   1        P0 = 0x00;
  77   1        init_ls138(4);
  78   1        P0 = 0xff;
  79   1        init_ls138(0);
  80   1      }
  81          void led_check()
  82          {
  83   1        unsigned char i;
  84   1        init_ls138(4);
  85   1        for(i = 0; i < 8; i++)
  86   1        {
  87   2          P0 = 0xfe << i;
  88   2          Delay100ms();
  89   2        }
  90   1        for(i = 0; i < 8; i++)
  91   1        {
  92   2          P0 = ~(~0x01 << i);
  93   2          Delay100ms();
  94   2        }
  95   1        init_ls138(0);
  96   1      }
  97          void smg_check()
  98          {
  99   1        unsigned char i;
 100   1        for(i = 0; i < 8; i++)
 101   1        {
 102   2          init_ls138(6);
 103   2          P0 = ~(~0x01 << i);
 104   2          init_ls138(7);
 105   2          P0 = 0x00;
 106   2          Delay100ms();
 107   2        }
 108   1        for(i = 0; i < 8; i++)
 109   1        {
 110   2          init_ls138(6);
 111   2          P0 = 0xfe << i;
 112   2          init_ls138(7);
 113   2          P0 = 0x00;
 114   2          Delay100ms();
 115   2        }
 116   1        init_ls138(0);
C51 COMPILER V9.60.0.0   T9                                                                01/09/2023 19:43:07 PAGE 3   

 117   1      }
 118          void Timer0Init(void)   //50毫秒@11.0592MHz
 119          {
 120   1        AUXR &= 0x7F;   //定时器时钟12T模式
 121   1        TMOD &= 0xF0;   //设置定时器模式
 122   1        TL0 = 0x00;   //设置定时初始值
 123   1        TH0 = 0x4C;   //设置定时初始值
 124   1        TF0 = 0;    //清除TF0标志
 125   1        ET0 =1;
 126   1        TR0 = 1;    //定时器0开始计时
 127   1      }
 128          void UartInit(void)   //9600bps@11.0592MHz
 129          {
 130   1        PCON &= 0x7F;   //波特率不倍速
 131   1        SCON = 0x50;    //8位数据,可变波特率
 132   1        AUXR |= 0x40;   //定时器时钟1T模式
 133   1        AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
 134   1        TMOD &= 0x0F;   //设置定时器模式
 135   1        TMOD |= 0x20;   //设置定时器模式
 136   1        TL1 = 0xDC;   //设置定时初始值
 137   1        TH1 = 0xDC;   //设置定时重载值
 138   1        ET1 = 0;    //禁止定时器%d中断
 139   1        ES =1;
 140   1        TR1 = 1;    //定时器1开始计时
 141   1      }
 142          void service_t0() interrupt 1
 143          {
 144   1        count++;
 145   1        if(count == 20)
 146   1        {
 147   2          sec++;
 148   2          count = 0;
 149   2          if(sec == 60)
 150   2          {
 151   3            min++;
 152   3            sec = 0;
 153   3            if(min == 60)
 154   3            {
 155   4              hour++;
 156   4              min = 0;
 157   4              if(hour == 100)
 158   4              {
 159   5                hour = 0;
 160   5              }
 161   4            }
 162   3          }
 163   2        }
 164   1      }
 165          void smg_show()
 166          {
 167   1        unsigned char i;
 168   1        dspbuf[0] = tab[hour / 10];
 169   1        dspbuf[1] = tab[hour % 10];
 170   1        dspbuf[2] = 0xbf;
 171   1        dspbuf[3] = tab[min / 10];
 172   1        dspbuf[4] = tab[min % 10];
 173   1        dspbuf[5] = 0xbf;
 174   1        dspbuf[6] = tab[sec / 10];
 175   1        dspbuf[7] = tab[sec % 10];
 176   1        
 177   1        for(i = 0; i < 8; i++)
 178   1        {
C51 COMPILER V9.60.0.0   T9                                                                01/09/2023 19:43:07 PAGE 4   

 179   2          init_ls138(6);
 180   2          P0 = 0x01 << i;
 181   2          init_ls138(7);
 182   2          P0 = dspbuf[i];
 183   2          Delay1ms();
 184   2        }
 185   1        init_ls138(0);
 186   1      }
 187          void key_alone()
 188          {
 189   1        if(s5 == 0)
 190   1        {
 191   2          smg_show();
 192   2          if(s5 == 0)
 193   2          {
 194   3            while(s5 == 0)
 195   3            {
 196   4              smg_show();
 197   4            }
 198   3            init_ls138(4);
 199   3            led = (led | 0x80) & (~led | 0x7f);
 200   3            P0 = led;
 201   3            init_ls138(0);
 202   3          }
 203   2        }
 204   1        if(s4 == 0)
 205   1        {
 206   2          smg_show();
 207   2          if(s4 == 0)
 208   2          {
 209   3            while(s4 == 0)
 210   3            {
 211   4              smg_show();
 212   4            }
 213   3            init_ls138(4);
 214   3            led = (led | 0x40) & (~led | 0xbf);
 215   3            P0 = led;
 216   3            init_ls138(0);
 217   3          }
 218   2        } 
 219   1      }
 220          void service_uart() interrupt 4
 221          {
 222   1        if(RI == 1)
 223   1        {
 224   2          RI = 0;
 225   2          r_sbuf = SBUF;
 226   2        }
 227   1      }
 228          void sendchar(unsigned char Char)
 229          {
 230   1        SBUF = Char;
 231   1        while(TI == 0);
 232   1        TI = 0;
 233   1      }
 234          void command()
 235          {
 236   1        if((r_sbuf & 0xf0) == 0xa0)
 237   1        {
 238   2          init_ls138(4);
 239   2          P0 = (led & 0xf0) | ~(r_sbuf | 0xf0);
 240   2          init_ls138(0);
C51 COMPILER V9.60.0.0   T9                                                                01/09/2023 19:43:07 PAGE 5   

 241   2        }
 242   1        else if(r_sbuf == 0xb0)
 243   1        {
 244   2          
 245   2          sendchar(((hour / 10) << 4) + (hour % 10));
 246   2          sendchar(((min / 10) << 4) + (min % 10));
 247   2          sendchar(((sec / 10) << 4) + (sec % 10));
 248   2          r_sbuf = 0;
 249   2        }
 250   1      }
 251          //================================================
 252          void Delay100ms()   //@11.0592MHz
 253          {
 254   1        unsigned char i, j, k;
 255   1      
 256   1        _nop_();
 257   1        _nop_();
 258   1        i = 5;
 259   1        j = 52;
 260   1        k = 195;
 261   1        do
 262   1        {
 263   2          do
 264   2          {
 265   3            while (--k);
 266   3          } while (--j);
 267   2        } while (--i);
 268   1      }
 269          void Delay1ms()   //@11.0592MHz
 270          {
 271   1        unsigned char i, j;
 272   1      
 273   1        _nop_();
 274   1        _nop_();
 275   1        _nop_();
 276   1        i = 11;
 277   1        j = 190;
 278   1        do
 279   1        {
 280   2          while (--j);
 281   2        } while (--i);
 282   1      }
 283          
 284          
 285            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    719    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
